**子重新网格化：**

子重新网格化是一个预处理步骤，用于处理输入网格中极度扭曲的三角形(如薄而长的三角形)，边分裂算法流程如下：

1. 计算网格中所有边的平均长度$E_{ave}$

2. 检测所有长度大于$2 \times E_{ave}$的边，并将其加入待分裂边集合${E_d}$

3. 对于每条待分裂边$e \in \{E_d\}$：

   计算当前边的长度$E_e$，计算需要插入的点数$n=[E_e/E_{ave}]$，在边上插入$n$个点，将边分割成$n+1$段，更新顶点列表

4. 对于共享这些边的面，进行局部重新连接，生成新的三角形，确保新边的长度不超过$2 \times E_{ave}$

**局部重新连接**：

分为两种情况

(a) 三角形只有一条边需要分裂(原三角形有一条长边，另外两条边相对较短)

1) 在长边上插入$n$个点(等距分割)
2) 在另外两条边上也插入相同数量的点
3) 按顺序连接对应点，形成一系列相邻的四边形
4) 每个四边形再被对角线分割成两个三角形

(b) 三角形有两条边需要分裂(原三角形有两条相对较长的边)

1) 在最长的边上插入$n$个点
2) 在第二长的边上插入相同数量的点
3) 短边可能不需要插入点或插入较少点
4) 按上述方式连接点

<img src="C:\Users\sxl08\AppData\Roaming\Typora\typora-user-images\image-20250923203127102.png" alt="image-20250923203127102," style="zoom:67%;" />

避免钝角策略：选择对角线分割时，优先选择能产生更均衡三角形的哪条对角线，确保没有产生多大的钝角

**基于直方图的边缘重新连接中的边分裂：**

如果一条边的长度大于$\frac{5}{4}\times\min\{m_a,m_b]$，则进行边分裂。其中，

$m_a$和$m_b$是该边两个端点分配的乘法因子，这些因子根据顶点的曲率值通过直方图分析确定，乘法因子$m$反映了曲率变化；高曲率区域分配较大的$m$值(导致更密的网格)，低曲率部分分配较小的$m$值

算法流程如下：

1) 计算每个顶点的曲率值，并通过平滑处理生成$CSF$
2) 计算网格的平均边长度$l$
3) 根据$CSF$的曲率值，为每个顶点分配乘法因子$m$(通过直方图分组，例如$k=5$，$m$的值可能为${1.8,1.4,1.0,0.8,0.6}$)
4) 对于每条边：如果边长度＞$\frac{5}{4}\times\min\{m_a,m_b]$，则分裂该边(通过插入顶点)，分裂后，可能还需要进行边折叠、翻转或顶点重新定位以优化网格
5) 对于每条边：如果边长度<$\frac{5}{4}\times\max\{m_a,m_b]$，则塌陷该边，将两个端点合并为一个新顶点(位于中点)

**如何得到乘法因子**

计算每个顶点$x_i$的初始曲率值$s(x_i)$:
$$
s(x_i)=\max_{x_j\in R(x_i)}\{\arccos(N(x_i)\cdot N(x_j))\}
$$
其中，$R(x_i)$是顶点$x_i$的1环领域，$N(x_i)$是顶点$x_i$的法向量。曲率值直观地表示了顶点领域内的最大弯曲程度

使用拉普拉斯平滑对初始曲率场进行平滑，拉普拉斯算子定义为：
$$
\Delta s_i=\sum_{j\in R_i}\left(\frac{w_{ij}}{w_i}\cdots_j\right)-s_i
$$
其中，$w_i=\sum_{j\in R_i}w_{ij}$，而$w_{ij}$是余切权重，定义为：
$$
w_{ij}=\frac{\cot\alpha+\cot\beta}{2}
$$
其中，$\alpha$和$\beta$是边$x_i$，$x_j$所对的两个角。如果余切权重为负，则将其设为一个小的正数$\eta$(如0.0001)

平滑过程是迭代的，每次更新每个顶点的曲率值：
$$
s_i\leftarrow s_i+(1-\mu)\cdot\Delta s_i
$$
其中，$\mu$是控制更新速率的权重，默认设为0.5

为了避免平滑过程中使所有曲率趋于相同，论文选择曲率最大的顶点$v_{max}$和不在其1环邻域内曲率最小的顶点$v_{min}$，不对这两个顶点进行平滑。这样可以在平滑的同时保持曲率场的特征。

将曲率值分布分成$k$个区间($k$是用户预设的奇数，默认为5)。区间划分方法如下：

1. 计算曲率值的直方图，选择出现次数最多的曲率值作为基准值。如果有多个最大值，选择中间位置的。

2. 设$T_r$为曲率大于基准值的顶点数，$T_l$为曲率不大于基准值的顶点数

3. 将曲率范围$\begin{bmatrix} s_0,s_k \end{bmatrix}$($s_0$和$s_k$分别是曲率最小值和最大值)划分为$k$个区间，使得：

   ​	对于左半部分$(l\leq k/2)$，每个区间包含$2T_{l}/k$个顶点

   ​	对于右半部分$(r\geq k/2)$，每个区间包含$2T_{r}/k$个顶点

4. 为每个区间分配一个乘法因子值$m_g\mathrm{(}g=1,2,\cdots,k)$。论文中对于$k=5$，设定：
   $$
   \{m_1,m_2,m_3,m_4,m_5\}=\{1.8,1.4,1.0,0.8,0.6\}
   $$

5. 对于每个顶点$p_i$，根据其平滑曲率值$s(p_i)$所在的区间，分配对应的乘法因子$m_g$

**通过上述过程，得到了每个顶点的乘法因子。高曲率区域的顶点将获得较大的乘法因子，从而使得这些区域的边更容易被分裂(因为分裂条件的阈值变小)，进而生成更密的网格，低曲率相反(m还是缩放因子，作用在期望边长上，高曲率区域分配大m，相同的物理边会被判定成太长，从而更容易分裂)**

